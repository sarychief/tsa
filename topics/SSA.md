## Сингулярный Спектральный Анализ / Метод “Гусеница” / SSA

Этапы:
- Разложение:
	- Шаг вложения
	- Шаг сингулярного разложения
- Восстановление:
	- Шаг группировки
	- Шаг диагонального усреднения

---

## Этап Разложения

Входные данные
Исходный ряд: $\large F= f(t) = \{f(t_0), ... , f(t_{N-1})\},\ \ t_i = i\Delta t$
Длина окна $L$: $\large 1 < L < N;\ \ \ \ \ K = N- L +1$

\1. Шаг вложения: $X_i = (f_{i-1},..., f_{i + L-2})^T,\ \ 1 \le i \le K$
Создаем Траекторную матрицу $X$
$X = [X_1:...:X_K]$

![[Untitled9.png]]

По столбцам отсчеты и след + 1

\2. Сингулярное разложение ([SVD](https://www.youtube.com/watch?v=HyE-W_BzsSk)): $X^2 = S = XX^T$

В результате получим:
- Собственные числа: $\lambda_1,...,\lambda_L$
$(\lambda_1 \ge\lambda_2\ge ... \ge \lambda_L \ge 0)$

- Собственные вектора: $U_1,...,U_L$
Тогда пусть $d = \max\{i:\lambda_i > 0\}$ и $\large V_i= X^T\frac{U_i}{\sqrt{\lambda_i}},\ \ i=1,...,d$

В итоге $X = X_1 + ... X_d$ где $\color{gold}X_i=\sqrt{\lambda_i}U_iV^T_i$

Представляем исходную матрицу $S$ в лице произведения собственных чисел, собственных векторов и транспонированных собственных векторов $(\sqrt{\lambda_i},U_i,V^T_i)$

> SVD разлагает матрицу X на три компоненты: собственные векторы (U), сингулярные значения (λ) и правые собственные векторы (V). Алгоритм SVD широко используется в линейной алгебре и науке о данных для различных задач, таких как сжатие данных, снижение размерности, решение систем линейных уравнений и анализ данных.

> В описанном алгоритме:

> Собственные числа (λ) представляют собой масштабные коэффициенты для собственных векторов (U).

> Собственные векторы (U) образуют базис, в котором матрица X имеет диагональную форму.

> Правые собственные векторы (V) используются для восстановления исходной матрицы X.

> Алгоритм SVD разлагает матрицу X на сумму компонентов X1, ..., Xd, где Xi = √(λi)UiVi^T.

---

### Этап восстановления


\1. Группировка компонент:

- Делим множество индексов на непересекающиеся подмножества $l_1,...,l_m$
- Пере-комбинируем индексы по нашему желанию $I = \{i_1,...,i_p\}\ \ X_I = X_{i_1}+...+X_{i_p}$
- В соответствии изменяем разложение: $X = X_{I_1} + ... + X_{I_m}$

> Например: $X = a + b + c + ... + g + h$

> Стало после группировки: $X = (a) + (b+c) + (d+e) + (f+g+h)$$X + (a) + (b+c) + (d+e) + (f+g+h)$

> В итоге: $X = g_0 + g_1 + g_2 + g_3$

\2. Диагональное усреднение:

- Переводим новую группировку матрицы обратно во временные ряды
- Положим $L^* = \min(L, K),K^* = \min(L,K)$
- $y^*_{ij} = y_{ij}$ если $L \le K$ и $y^*_{ij} = y_{ij}$ - иначе

Восстановленный ряд будет $G$: $g_0,...,g_{N-1}$

![[Untitled10.png]]

### До/после

![[Untitled11.png]]
![[Base/Files/Untitled12.png]]


## Проблемы

они же входные параметры:

- [Длина окна](https://www.notion.so/2-3-1-23ba04c9c14c4ea296d0f90c7d5c25c2?pvs=21)
- нет смыла брать больше половины длины ряда
- чем больше длина окна, тем более детальное разложение
- маленькая длина окна приводит к низкой дитализации
- лучше брать длину окна кратной периоду этой компоненты
- [Выбор способа группировки](https://www.notion.so/2-3-1-23ba04c9c14c4ea296d0f90c7d5c25c2?pvs=21)
- базовая модель предполагается адитивной, поэтому те компоненты что мы хотим найти (например сезоны) в их диапазоне и стоит объединять
- если убрать шум - это все то, что не сгруппировали собственные тройки